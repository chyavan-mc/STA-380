# 1. Probability practice

## Part. A
Visitors to your website are asked to answer a single survey question before they get access to the content on the page. Among all of the users, there are two categories: Random Clicker (RC), and Truthful Clicker (TC). There are two possible answers to the survey: yes and no. Random clickers would click either one with equal probability. You are also giving the information that the expected fraction of random clickers is 0.3.  After a trial period, you get the following survey results: 65\% said Yes and 35\% said No.   What fraction of people who are truthful clickers answered yes?  Hint: use the rule of total probability.

> Lets start with the mathematical representations of all the fractions we know, <br>
> $P(Y) = 0.65 \rightarrow$ Marginal probability of a clicker saying Yes <br>
> $P(N) = 0.35 \rightarrow$ Marginal probability of a clicker saying No <br>
> $P(R_{c}) = 0.3 \rightarrow$ Probability of a clicker being a random clicker <br>
> $P(T_{c}) = 0.7 \rightarrow$ Probability of a clicker being a truthful clicker <br>
> 
> To find the fraction of people truthful clickers who answered yes, we find the value of $P(Y|T_{c})$
> 
> We know that, <br>
>   $P(Y) = P(Y|R_{c}) + P(Y|T_{c})$
> 
> Rearranging, <br>
>   $P(Y|T_{c}) = P(Y) - P(Y|R_{c})$
> 
> If a random clicker clicking *Yes* or *No* is equally likely, then the probability (or fraction) of Random clickers, clicking yes > is (Fraction of users among the 0.3 random clickers, clicking *Yes*), <br>
>   $P(Y|R_{c}) = 0.5*0.3 = 0.15$
> 
> Substituting in the rearranged equation, <br>
>   $P(Y|T_{c}) = 0.65 - 0.15$ <br>
>   $P(Y|T_{c}) = 0.5$
>
> Therefore, the fraction of clickers among truthful clickers who clicked yes would be **0.5**

## Part. B
Imagine a medical test for a disease with the following two attributes:  

- The sensitivity is about 0.993. That is, if someone has the disease, there is a probability of 0.993 that they will test positive.
- The specificity is about 0.9999. This means that if someone doesn't have the disease, there is probability of 0.9999 that they will test negative.
- In the general population, incidence of the disease is reasonably rare: about 0.0025% of all people have it (or 0.000025 as a decimal probability).

Suppose someone tests positive. What is the probability that they have the disease?

> Lets start with the mathematical representations of all the probabilities we know, <br>
>   $P(T_{p}|D) = 0.993 \rightarrow$ Probability of testing positive given a person has the disease <br>
>   $P(T_{n}|D_{c}) = 0.9999 \rightarrow$ Probability of testing negative given a person doesn't have the disease <br>
>   $P(D) = 0.000025 \rightarrow$ Probability of a person having the disease <br>
>   $P(D_{c}) = 1- P(D) = 0.999975$ \rightarrow Probability of a person not having the disease <br>
> 
> We'll find the probability of testing positive, given a person doesn't have the disease, i.e.
>   $P(T_{p}|D_{c}) = 1 - P(T_{n}|D_{c}) = 1 - 0.9999 = 0.0001$
> 
> Probability of having the disease given that someone tested positive <br>
>   $P(D|T_{p}) = \frac{P(T_{p}|D)*P(D)}{P(T_{p})}$ <br>
>   $P(D|T_{p}) = \frac{P(T_{p}|D)*P(D)}{P(T_{p}|D)*P(D) + P(T_{p}|D_{c})*P(D_{c})}$ <br>
>   $P(D|T_{p}) = \frac{0.993*0.000025}{0.993*0.000025 + 0.0001*0.999975}$ = 0.1989<br>
>   $P(D|T_{p}) = 0.1989 \rightarrow 19.89\%$ <br>
>
> Therefore, the probability of having the disease given that someone tested positive is **0.1989 or 19.89%**. It has significantly increased from the marginal probability of having the disease which was **0.000025 or 0.0025%**

# 2. Wrangling the Billboard Top 100

using [billboard.csv](./data/billboard.csv)
``` {r 2setup, include=FALSE}
library(dplyr)
library(tidyverse)

options(dplyr.summarise.inform = FALSE)
```

```{r 2pre}
billboard = read.csv("./data/billboard.csv")
billboard = billboard[,c("performer", "song", "year", "week", "week_position")]
# Considering the relevant columns as mentioned in the question
head(billboard)
```

## Part. A

Make a table of the top 10 most popular songs since 1958, as measured by the _total number of weeks that a song spent on the Billboard Top 100._  Note that these data end in week 22 of 2021, so the most popular songs of 2021 will not have up-to-the-minute data; please send our apologies to The Weeknd.    

Your table should have __10 rows__ and __3 columns__: `performer`, `song`, and `count`, where `count` represents the number of weeks that song appeared in the Billboard Top 100.  Make sure the entries are sorted in descending order of the `count` variable, so that the more popular songs appear at the top of the table.  Give your table a short caption describing what is shown in the table.  

(_Note_: you'll want to use both `performer` and `song` in any `group_by` operations, to account for the fact that multiple unique songs can share the same title.)  

``` {r 2a, warnings=FALSE}
top_songs_by_week = billboard %>% group_by(song, performer) %>% summarize(count = n())
top10_songs_by_week = head(top_songs_by_week[order(-top_songs_by_week$count),], 10)

knitr::kable(top10_songs_by_week,
             caption = "The Top 10 Songs (Jul 1958 - Jun 2021) by the number of weeks on the Billboard")
```

## Part. B

Is the "musical diversity" of the Billboard Top 100 changing over time?  Let's find out.  We'll measure the musical diversity of given year as _the number of unique songs that appeared in the Billboard Top 100 that year._  Make a line graph that plots this measure of musical diversity over the years.  The x axis should show the year, while the y axis should show the number of unique songs appearing at any position on the Billboard Top 100 chart in any week that year.  For this part, please filter the data set so that it excludes the years 1958 and 2021, since we do not have complete data on either of those years.   Give the figure an informative caption in which you explain what is shown in the figure and comment on any interesting trends you see.

There are number of ways to accomplish the data wrangling here.  We offer you two hints on two possibilities:  

1) You could use two distinct sets of data-wrangling steps.  The first set of steps would get you a table that counts the number of times that a given song appears on the Top 100 in a given year.  The second set of steps operate on the result of the first set of steps; it would count the number of unique songs that appeared on the Top 100 in each year, _irrespective of how many times_ it had appeared.
2) You could use a single set of data-wrangling steps that combines the `length` and `unique` commands. 

``` {r 2b, warnings=FALSE}
musical_diversity = billboard[,c("performer", "song", "year")] 
musical_diversity = musical_diversity %>% filter(!(year %in% c(2021, 1958)))
musical_diversity = unique(musical_diversity)
musical_diversity = musical_diversity %>% group_by(year) %>% summarize(unique=n())
musical_diversity = musical_diversity[order(musical_diversity$year),]

# plot(musical_diversity$year, musical_diversity$unique, type="l", col="red", xlab="Year", ylab="# of unique songs on the Billboard Top-100", main="Musical Diversity")

ggplot(data=musical_diversity, aes(x=year, y=unique, group=1)) +
  geom_line(color="red", size=1) +
  ggtitle("Musical Diversity") +
  xlab("Year") +
  ylab("# of unique songs on the Billboard Top-100")
```

## Part. C

Let's define a "ten-week hit" as a single song that appeared on the Billboard Top 100 for at least ten weeks.  There are 19 artists in U.S. musical history since 1958 who have had _at least 30 songs_ that were "ten-week hits."  Make a bar plot for these 19 artists, showing how many ten-week hits each one had in their musical career.   Give the plot an informative caption in which you explain what is shown.


_Notes_:  

1) You might find this easier to accomplish in two distinct sets of data wrangling steps.
2) Make sure that the individuals names of the artists are readable in your plot, and that they're not all jumbled together.  If you find that your plot isn't readable with vertical bars, you can add a `coord_flip()` layer to your plot to make the bars (and labels) run horizontally instead.
3) By default a bar plot will order the artists in alphabetical order.  This is acceptable to turn in.  But if you'd like to order them according to some other variable, you can use the `fct_reorder` function, described in [this blog post](https://datavizpyr.com/re-ordering-bars-in-barplot-in-r/).  This is optional.

``` {r 2c}
ten_week_hitters = top_songs_by_week %>%
  filter(count >= 10) %>%
  group_by(performer) %>%
  summarize(count = n()) %>%
  filter(count >= 30)

ggplot(data=ten_week_hitters, aes(x=reorder(performer, +count), y=count)) +
  geom_bar(stat="identity", fill="steelblue") +
  coord_flip()
```


# 3. Visual story telling part 1: Green Buildings

using [greenbuildings.csv](./data/greenbuildings.csv)





# Portfolio Modeling

For this question, we decided to do 3 different tests with different types of ETFs to understand the different gains and losses through bootstrapping. 

We first used Oil and Gas commodity ETFs to understand how much we would potentially be gaining or losing if we were to invest in them. 

```{r, include = FALSE}
library(mosaic)
library(quantmod)
library(foreach)

#### Now use a bootstrap approach
#### With more stocks

#Commodities

#USO: https://etfdb.com/etf/USO/
#UNG: https://etfdb.com/etf/UNG/
#OILK: https://etfdb.com/etf/OILK/
#GAZ: https://etfdb.com/etf/GAZ/
#RJN: https://etfdb.com/etf/RJN/

mystocks = c("USO", "UNG", "OILK", "GAZ", "RJN")
myprices = getSymbols(mystocks, from = "2017-08-13")

# A chunk of code for adjusting all stocks
# creates a new object adding 'a' to the end
# For example, WMT becomes WMTa, etc
for(ticker in mystocks) {
  expr = paste0(ticker, "a = adjustOHLC(", ticker, ")")
  eval(parse(text=expr))
}

head(USOa)

# Combine all the returns in a matrix
all_returns = cbind( ClCl(USOa),
                     ClCl(UNGa),
                     ClCl(OILKa),
                     ClCl(GAZa),
                     ClCl(RJNa))
```

These are the stocks we used for this portfolio: 

USO: United States Oil Fund LP

UNG: United States Natural Gas Fund LP

OILK: ProShares K-1 Free Crude Oil Strategy ETF

GAZ: iPath Series B Bloomberg Natural Gas Subindex Total Return ETN

RJN: Elements Rogers International Commodity Index-Energy Total Return ETN


```{r, echo = FALSE}
head(all_returns)
all_returns = as.matrix(na.omit(all_returns))
```

From the coefficients we can see the difference in each stocks and how they differ from day to day. We started measuring from 5 years back till today. 

We then made a pairs plot to see each ETF against each other

```{r, echo = FALSE}
# Compute the returns from the closing prices
pairs(all_returns)
```

We then simulate a random day to where we distribute each ETF to our $100K capital equally and then find the sum to compute our new total wealth at the end of the random day. 

```{r, echo = FALSE}
# Sample a random return from the empirical joint distribution
# This simulates a random day
return.today = resample(all_returns, 1, orig.ids=FALSE)

# Update the value of your holdings
# Assumes an equal allocation to each asset
total_wealth = 100000
my_weights = c(0.2,0.2,0.2, 0.2, 0.2)
holdings = total_wealth*my_weights
holdings = holdings*(1 + return.today)

# Compute your new total wealth
holdings
total_wealth = sum(holdings)
total_wealth
```

So as we can see on a random day we went from $100,000 in capital to the output.

We then observed the change over a time period of two weeks. 

```{r, echo = FALSE}
# Now loop over two trading weeks
# let's run the following block of code 5 or 6 times
# to eyeball the variability in performance trajectories

## begin block
total_wealth = 100000
weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
holdings = weights * total_wealth
n_days = 20  # capital T in the notes
wealthtracker = rep(0, n_days) # Set up a placeholder to track total wealth
for(today in 1:n_days) {
  return.today = resample(all_returns, 1, orig.ids=FALSE)  # sampling from R matrix in notes
  holdings = holdings + holdings*return.today
  total_wealth = sum(holdings)
  wealthtracker[today] = total_wealth
}
total_wealth
plot(wealthtracker, type='l')
## end block
```

So we can see the change in our capital over the time of 20 days.

So now we bootstrap this model.

```{r, echo = FALSE}
# Now simulate many different possible futures
# just repeating the above block thousands of times
initial_wealth = 100000
sim1 = foreach(i=1:5000, .combine='rbind') %do% {
  total_wealth = initial_wealth
  weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
  holdings = weights * total_wealth
  n_days = 20
  wealthtracker = rep(0, n_days)
  for(today in 1:n_days) {
    return.today = resample(all_returns, 1, orig.ids=FALSE)
    holdings = holdings + holdings*return.today
    total_wealth = sum(holdings)
    wealthtracker[today] = total_wealth
  }
  wealthtracker
}

# each row is a simulated trajectory
# each column is a data
head(sim1)
hist(sim1[,n_days], 25)
```

So we can see the distribution of capital after bootstrapping. It is mostly normal.

```{r, echo = FALSE}
# Profit/loss
mean(sim1[,n_days])
mean(sim1[,n_days] - initial_wealth)
hist(sim1[,n_days]- initial_wealth, breaks=30)

# 5% value at risk:
quantile(sim1[,n_days]- initial_wealth, prob=0.05)

# note: this is  a negative number (a loss, e.g. -500), but we conventionally
# express VaR as a positive number (e.g. 500)
```

So this is our ultimate gain/loss, which can vary from time to time. 


Our next portfolio is emerging market equities, which can be important for people who are interested in investing in new markets which can be relatively risky.

```{r, include = FALSE}
library(mosaic)
library(quantmod)
library(foreach)

#### Now use a bootstrap approach
#### With more stocks

#Commodities

#VTO: https://etfdb.com/etf/VTO/
#IEMG: https://etfdb.com/etf/IEMG/
#GEM: https://etfdb.com/etf/GEM/
#DEM: https://etfdb.com/etf/DEM/
#PXH: https://etfdb.com/etf/PXH/

mystocks = c("VTO", "IEMG", "GEM", "DEM", "PXH")
myprices = getSymbols(mystocks, from = "2017-08-13")

# A chunk of code for adjusting all stocks
# creates a new object adding 'a' to the end
# For example, WMT becomes WMTa, etc
for(ticker in mystocks) {
  expr = paste0(ticker, "a = adjustOHLC(", ticker, ")")
  eval(parse(text=expr))
}

head(USOa)

# Combine all the returns in a matrix
all_returns = cbind( ClCl(VTOa),
                     ClCl(IEMGa),
                     ClCl(GEMa),
                     ClCl(DEMa),
                     ClCl(PXHa))
```

These are the stocks we used for this portfolio: 

VTO: Vanguard FTSE Emerging Markets ETF

IEMG: iShares Core MSCI Emerging Markets ETF

GEM: Goldman Sachs ActiveBeta Emerging Markets Equity ETF

DEM: WisdomTree Emerging Markets High Dividend Fund

PXH: Invesco FTSE RAFI Emerging Markets ETF


```{r, echo = FALSE}
head(all_returns)
all_returns = as.matrix(na.omit(all_returns))
```

From the coefficients we can see the difference in each stocks and how they differ from day to day. We started measuring from 5 years back till today. 

We then made a pairs plot to see each ETF against each other

```{r, echo = FALSE}
# Compute the returns from the closing prices
pairs(all_returns)
```

We then simulate a random day to where we distribute each ETF to our $100K capital equally and then find the sum to compute our new total wealth at the end of the random day. 

```{r, echo = FALSE}
# Sample a random return from the empirical joint distribution
# This simulates a random day
return.today = resample(all_returns, 1, orig.ids=FALSE)

# Update the value of your holdings
# Assumes an equal allocation to each asset
total_wealth = 100000
my_weights = c(0.2,0.2,0.2, 0.2, 0.2)
holdings = total_wealth*my_weights
holdings = holdings*(1 + return.today)

# Compute your new total wealth
holdings
total_wealth = sum(holdings)
total_wealth
```

So as we can see on a random day we went from $100,000 in capital to output [1]. This amount varies from day to day.

We then observed the change over a time period of two weeks. 

```{r, echo = FALSE}
# Now loop over two trading weeks
# let's run the following block of code 5 or 6 times
# to eyeball the variability in performance trajectories

## begin block
total_wealth = 100000
weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
holdings = weights * total_wealth
n_days = 20  # capital T in the notes
wealthtracker = rep(0, n_days) # Set up a placeholder to track total wealth
for(today in 1:n_days) {
  return.today = resample(all_returns, 1, orig.ids=FALSE)  # sampling from R matrix in notes
  holdings = holdings + holdings*return.today
  total_wealth = sum(holdings)
  wealthtracker[today] = total_wealth
}
total_wealth
plot(wealthtracker, type='l')
## end block
```

So we can see the change in our capital over the time of 20 days.

So now we bootstrap this model.

```{r, echo = FALSE}
# Now simulate many different possible futures
# just repeating the above block thousands of times
initial_wealth = 100000
sim1 = foreach(i=1:5000, .combine='rbind') %do% {
  total_wealth = initial_wealth
  weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
  holdings = weights * total_wealth
  n_days = 20
  wealthtracker = rep(0, n_days)
  for(today in 1:n_days) {
    return.today = resample(all_returns, 1, orig.ids=FALSE)
    holdings = holdings + holdings*return.today
    total_wealth = sum(holdings)
    wealthtracker[today] = total_wealth
  }
  wealthtracker
}

# each row is a simulated trajectory
# each column is a data
head(sim1)
hist(sim1[,n_days], 25)
```

So we can see the distribution of capital after bootstrapping. It is mostly normal. 

```{r, echo = FALSE}
# Profit/loss
mean(sim1[,n_days])
mean(sim1[,n_days] - initial_wealth)
hist(sim1[,n_days]- initial_wealth, breaks=30)

# 5% value at risk:
quantile(sim1[,n_days]- initial_wealth, prob=0.05)

# note: this is  a negative number (a loss, e.g. -500), but we conventionally
# express VaR as a positive number (e.g. 500)
```

So our ultimate gain/loss would be output [1]. This could vary due to randomization in bootstrapping. 

The last portfolio we used is with Health and Biotech Equities, which is slightly less common but still has a large capital. 

```{r, include = FALSE}
library(mosaic)
library(quantmod)
library(foreach)

#### Now use a bootstrap approach
#### With more stocks

#Commodities

#XHE: https://etfdb.com/etf/XHE/
#PSCH: https://etfdb.com/etf/PSCH/
#IHE: https://etfdb.com/etf/IHE/
#PBE: https://etfdb.com/etf/PBE/
#FHLC: https://etfdb.com/etf/FHLC/

mystocks = c("XHE", "PSCH", "IHE", "PBE", "FHLC")
myprices = getSymbols(mystocks, from = "2017-08-13")

# A chunk of code for adjusting all stocks
# creates a new object adding 'a' to the end
# For example, WMT becomes WMTa, etc
for(ticker in mystocks) {
  expr = paste0(ticker, "a = adjustOHLC(", ticker, ")")
  eval(parse(text=expr))
}

head(USOa)

# Combine all the returns in a matrix
all_returns = cbind( ClCl(XHEa),
                     ClCl(PSCHa),
                     ClCl(IHEa),
                     ClCl(PBEa),
                     ClCl(FHLCa))
```

These are the stocks we used for this portfolio: 

XHE: SPDR S&P Health Care Equipment ETF

PSCH: Invesco S&P SmallCap Health Care ETF

IHE: IShares U.S. Pharmaceuticals ETF

PBE: Invesco Dynamic Biotechnology & Genome ETF

FHLC: Fidelity MSCI Health Care Index ETF


```{r, echo = FALSE}
head(all_returns)
all_returns = as.matrix(na.omit(all_returns))
```

From the coefficients we can see the difference in each stocks and how they differ from day to day. We started measuring from 5 years back till today. 

We then made a pairs plot to see each ETF against each other

```{r, echo = FALSE}
# Compute the returns from the closing prices
pairs(all_returns)
```

We then simulate a random day to where we distribute each ETF to our $100K capital equally and then find the sum to compute our new total wealth at the end of the random day. 

```{r, echo = FALSE}
# Sample a random return from the empirical joint distribution
# This simulates a random day
return.today = resample(all_returns, 1, orig.ids=FALSE)

# Update the value of your holdings
# Assumes an equal allocation to each asset
total_wealth = 100000
my_weights = c(0.2,0.2,0.2, 0.2, 0.2)
holdings = total_wealth*my_weights
holdings = holdings*(1 + return.today)

# Compute your new total wealth
holdings
total_wealth = sum(holdings)
total_wealth
```

So as we can see on a random day we went from $100,000 in capital to output[1]. 

We then observed the change over a time period of two weeks. 

```{r, echo = FALSE}
# Now loop over two trading weeks
# let's run the following block of code 5 or 6 times
# to eyeball the variability in performance trajectories

## begin block
total_wealth = 100000
weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
holdings = weights * total_wealth
n_days = 20  # capital T in the notes
wealthtracker = rep(0, n_days) # Set up a placeholder to track total wealth
for(today in 1:n_days) {
  return.today = resample(all_returns, 1, orig.ids=FALSE)  # sampling from R matrix in notes
  holdings = holdings + holdings*return.today
  total_wealth = sum(holdings)
  wealthtracker[today] = total_wealth
}
total_wealth
plot(wealthtracker, type='l')
## end block
```

So we can see the change in our capital over the time of 20 days.

So now we bootstrap this model.

```{r, echo = FALSE}
# Now simulate many different possible futures
# just repeating the above block thousands of times
initial_wealth = 100000
sim1 = foreach(i=1:5000, .combine='rbind') %do% {
  total_wealth = initial_wealth
  weights = c(0.2, 0.2, 0.2, 0.2, 0.2)
  holdings = weights * total_wealth
  n_days = 20
  wealthtracker = rep(0, n_days)
  for(today in 1:n_days) {
    return.today = resample(all_returns, 1, orig.ids=FALSE)
    holdings = holdings + holdings*return.today
    total_wealth = sum(holdings)
    wealthtracker[today] = total_wealth
  }
  wealthtracker
}

# each row is a simulated trajectory
# each column is a data
head(sim1)
hist(sim1[,n_days], 25)
```

So we can see the distribution of capital after bootstrapping. It is mostly normal. 

```{r, echo = FALSE}
# Profit/loss
mean(sim1[,n_days])
mean(sim1[,n_days] - initial_wealth)
hist(sim1[,n_days]- initial_wealth, breaks=30)

# 5% value at risk:
quantile(sim1[,n_days]- initial_wealth, prob=0.05)

# note: this is  a negative number (a loss, e.g. -500), but we conventionally
# express VaR as a positive number (e.g. 500)
```

So our ultimate gain/loss would be output [1], however this could change due to randomization in bootstrapping.

When we compare all three, we can see which portfolio is better to invest in, as it gains more capital or loses the least. 

# Market Segmentation

The social marketing data set consists of users and their different tweets categorized into 35 main topics. Our goal was to define a "market segment" using this data set. We initially took a look at the data and decided which type of analysis was to fit best to define the market segment. 

Since there were likely to be groups of different types of tweets, we decided to take a look at hierarchical clustering, however this did not end with favorable results, as there are too many splits on the decision tree and whichever k we chose was leading to an uneven distribution. Even with a K++ cluster we ended up with very high numbers, and decided to move to the next type of analysis. 

```{r, include = FALSE}
library(tidyverse)
library(ggplot2)
library(ggcorrplot)

social_marketing <- read.csv("C:/Users/tanvi/Downloads/social_marketing.csv", row.names = 1)

social_marketing <- cbind(User = rownames(social_marketing), social_marketing)
rownames(social_marketing) <- 1:nrow(social_marketing)

social_results = social_marketing %>%
  group_by(User) %>% 
  select(-User) %>%
  summarize_all(mean) %>%
  column_to_rownames(var="User")
```

We then attempted PCA to understand through which factors leads in the most variance of the data set. This split could potentially be defined as the market segment, so we decided to take a look into that. 

We ran a quick few plots to see the relationship between the User and various categories. In the following graphs we can see the relationship between chatter tweets by the user and travel tweets by the user respectively.

```{r, echo = FALSE}
ggplot(rownames_to_column(social_results, "User")) + 
  geom_col(aes(x=reorder(User, -chatter), y = chatter)) + 
  coord_flip()

ggplot(rownames_to_column(social_results, "User")) + 
  geom_col(aes(x=reorder(User, -travel), y = travel)) + 
  coord_flip()
```

We can see that there is some sort of relationship, so we proceeded with PCA.

We took a more general look at the correlation between each variable in the following graph.

```{r, echo = FALSE}
# a look at the correlation matrix
#cor(social_results)

# looks a mess -- reorder the variables by hierarchical clustering
ggcorrplot::ggcorrplot(cor(social_results), hc.order = TRUE)
```

Looking through the correlation plot, we can see some variables that have a fairly strong correlation with each other.

Next we took a look at the distribution of variance among the data set. This will then split our PCs so we can observe them individually. 

```{r, echo = FALSE}
# Now look at PCA of the (average) survey responses.  
PCApilot = prcomp(social_results, scale=TRUE)

## variance plot
plot(PCApilot)
summary(PCApilot)
```

We can see that around PC16 gives us around 75% of the cumulative proportion, which is around 1/2 of the PCs. So we decided to take a look at a few.

The following table shows the first 10 PCs. We decided to take a look at the first three to see if we can draw a conclusion.

```{r, echo = FALSE}
# first few pcs
# try interpreting the loadings
# the question to ask is: "which variables does this load heavily on (positive and negatively)?"
round(PCApilot$rotation[,1:10],2) 

# create a tidy summary of the loadings
loadings_summary = PCApilot$rotation %>%
  as.data.frame() %>%
  rownames_to_column('Question')
```

```{r, echo = FALSE}
# not sure yet
loadings_summary %>%
  select(Question, PC1) %>%
  arrange(desc(PC1))
```

After looking at PC1, we did not find any obvious meaning of the vectors, meaning that it is likely noise, so we proceeded to the next PC.

```{r, echo = FALSE}
#  this looks like influencer tweets vs serious tweets
loadings_summary %>%
  select(Question, PC2) %>%
  arrange(desc(PC2))
```

Looking at the categories for the tweets and how they are arranged, we can see that there is a separation between recreational tweets such as cooking, shopping, fashion, and serious tweets such as politics and news.

Now lets look at PC3.

```{r, echo = FALSE}
loadings_summary %>%
  select(Question, PC3) %>%
  arrange(desc(PC3))
```

PC3 looks similar to PC2, except that some of the variables have different vectors. We can conclude that this is also similar to recreational or influencer tweets vs serious tweets.

We then made some plots using the PCs that worked. 

```{r, include = FALSE}
# Let's make some plots of the shows themselves in 
# PC space, i.e. the space of summary variables we've created

social_marketing <- read.csv("./data/social_marketing.csv", row.names = 1)


social_marketing = merge(social_marketing, PCApilot$x[,1:3], by="row.names")
social_marketing = rename(social_marketing, social_marketing = Row.names)
```


```{r, echo = FALSE}

# let's plot in PC1 space
# We might feel good calling PC1 the "quality drama" PC
ggplot(social_marketing) + 
  geom_col(aes(x=reorder(social_marketing, PC2), y=PC2)) + 
  coord_flip()

```

```{r, echo = FALSE}
# looks like a "lighthearted vs serious" PC
ggplot(social_marketing) + 
  geom_col(aes(x=reorder(social_marketing, PC3), y=PC3)) + 
  coord_flip()
```

Both of these graphs look similar but have a distinct distribution

```{r, echo = FALSE}
# principal component regression: predicted engagement
lm1 = lm(travel ~ PC1 + PC2 + PC3, data=social_marketing)
summary(lm1)

# gross ratings points
lm2 = lm(college_uni ~ PC1 + PC2 + PC3, data=social_marketing)
summary(lm2)

# Conclusion: we can predict engagement and ratings
# with PCA summaries of the pilot survey.
# probably too much variance to regress on all survey questions!
# since the sample size isn't too large here.
plot(travel ~ fitted(lm1), data=social_marketing)
plot(college_uni ~ fitted(lm2), data=social_marketing)
```
After plotting linear models with all 3 PCs, we can see that the main difference in tweets is recreational vs serious. We can use this to define our market segment. In this dataset, the market is separated by the types of tweets that are recreational and serious. It shows the main differences in tweets by users. 
